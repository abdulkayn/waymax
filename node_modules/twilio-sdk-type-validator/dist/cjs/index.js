'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

var type = function () {
    var checks = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        checks[_i] = arguments[_i];
    }
    return ({
        mode: "type",
        checks: checks,
    });
};
var literal = function () {
    var checks = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        checks[_i] = arguments[_i];
    }
    return ({
        mode: "literal",
        checks: checks,
    });
};
var custom = function () {
    var checks = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        checks[_i] = arguments[_i];
    }
    return ({
        mode: "custom",
        checks: checks,
    });
};
var nonEmptyString = custom(function (value) { return [
    typeof value === "string" && value.length > 0,
    "a non-empty string",
]; });
var nonNegativeInteger = custom(function (value) { return [
    typeof value === "number" && Number.isInteger(value) && value >= 0,
    "a non-negative integer",
]; });
var pureObject = custom(function (value) { return [
    typeof value === "object" && value !== null && !Array.isArray(value),
    "a pure object (non-null and non-array)",
]; });
var objectSchema = function (name, schema) {
    return custom(function (object) {
        var e_1, _a;
        if (typeof object !== "object" ||
            object === null ||
            Array.isArray(object)) {
            return [false, "valid " + name + " (should be a pure object)"];
        }
        try {
            for (var _b = __values(Object.entries(schema)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = __read(_c.value, 2), key = _d[0], rules = _d[1];
                var _e = __read(validateValue(convertRuleArgument(rules), object[key]), 3), isValid = _e[0], received = _e[1], expected = _e[2];
                if (!isValid) {
                    return [
                        false,
                        "valid " + name + " (key \"" + key + "\" should be " + expected + ")",
                        "malformed " + name + " (key \"" + key + "\" is " + received + ")",
                    ];
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return [true];
    });
};
var runtimeTypeValidation = function (rules, values) {
    var e_2, _a;
    if (values.length > rules.length) {
        throw new Error("Expected at most " + rules.length + " argument(s), but got " + values.length);
    }
    while (values.length < rules.length) {
        values.push(undefined);
    }
    try {
        for (var _b = __values(values.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var _d = __read(_c.value, 2), index = _d[0], value = _d[1];
            var _e = __read(validateValue(rules[index], value), 4), isValid = _e[0], received = _e[1], expected = _e[2], delimeter = _e[3];
            if (isValid) {
                continue;
            }
            var argumentIndex = index + 1;
            throw new Error("Argument " + argumentIndex + " is expected to be " + expected + delimeter + " but got " + received);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_2) throw e_2.error; }
    }
};
var stringifyReceivedType = function (value) {
    var _a, _b;
    var receivedType;
    var types = ["undefined", "boolean", "number", "bigint", "string"];
    if (types.includes(typeof value)) {
        receivedType = typeof value === "string" ? "\"" + value + "\"" : "" + value;
    }
    if (typeof value === "object" && ((_a = value === null || value === void 0 ? void 0 : value.constructor) === null || _a === void 0 ? void 0 : _a.name) !== "Object") {
        receivedType =
            value === null ? "null" : "instance of " + ((_b = value === null || value === void 0 ? void 0 : value.constructor) === null || _b === void 0 ? void 0 : _b.name);
    }
    if (!receivedType) {
        receivedType = typeof value;
    }
    return receivedType;
};
var validateTypes = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var finalRuleSet = convertRuleArguments(args);
    return function (target, propertyKey, descriptor) {
        if (typeof descriptor.value !== "function") {
            throw new Error("The validateTypes decorator can only be applied to methods");
        }
        var originalMethod = descriptor.value;
        descriptor.value = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            runtimeTypeValidation(finalRuleSet, args);
            return originalMethod.apply(this, args);
        };
    };
};
var validateTypesAsync = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var finalRuleSet = convertRuleArguments(args);
    return function (target, propertyKey, descriptor) {
        if (typeof descriptor.value !== "function") {
            throw new Error("The validateTypesAsync decorator can only be applied to methods");
        }
        var originalMethod = descriptor.value;
        descriptor.value = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            try {
                runtimeTypeValidation(finalRuleSet, args);
            }
            catch (e) {
                return Promise.reject(e);
            }
            return originalMethod.apply(this, args);
        };
    };
};
var convertRuleArguments = function (args) {
    var e_3, _a;
    var finalRuleDefinitionSet = [];
    try {
        for (var args_1 = __values(args), args_1_1 = args_1.next(); !args_1_1.done; args_1_1 = args_1.next()) {
            var arg = args_1_1.value;
            finalRuleDefinitionSet.push(convertRuleArgument(arg));
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (args_1_1 && !args_1_1.done && (_a = args_1.return)) _a.call(args_1);
        }
        finally { if (e_3) throw e_3.error; }
    }
    return finalRuleDefinitionSet;
};
var convertRuleArgument = function (arg) {
    var e_4, _a;
    var finalArgumentRuleDefinitions = [];
    var declaredRules = Array.isArray(arg) ? arg : [arg];
    try {
        for (var declaredRules_1 = __values(declaredRules), declaredRules_1_1 = declaredRules_1.next(); !declaredRules_1_1.done; declaredRules_1_1 = declaredRules_1.next()) {
            var rule = declaredRules_1_1.value;
            if (typeof rule === "string" || typeof rule === "function") {
                finalArgumentRuleDefinitions.push(type(rule));
                continue;
            }
            finalArgumentRuleDefinitions.push(rule);
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (declaredRules_1_1 && !declaredRules_1_1.done && (_a = declaredRules_1.return)) _a.call(declaredRules_1);
        }
        finally { if (e_4) throw e_4.error; }
    }
    return finalArgumentRuleDefinitions;
};
var validateValue = function (ruleDefinitions, value) {
    var e_5, _a, e_6, _b, e_7, _c, e_8, _d;
    var expectedTypes = [];
    var customReceivedType;
    var isValid = false;
    try {
        for (var ruleDefinitions_1 = __values(ruleDefinitions), ruleDefinitions_1_1 = ruleDefinitions_1.next(); !ruleDefinitions_1_1.done; ruleDefinitions_1_1 = ruleDefinitions_1.next()) {
            var definition = ruleDefinitions_1_1.value;
            switch (definition.mode) {
                case "type":
                    try {
                        for (var _e = (e_6 = void 0, __values(definition.checks)), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var type_1 = _f.value;
                            if (typeof type_1 === "string") {
                                isValid = isValid || typeof value === type_1;
                                expectedTypes.push("of type " + type_1);
                                continue;
                            }
                            isValid = isValid || value instanceof type_1;
                            expectedTypes.push("an instance of " + type_1.name);
                        }
                    }
                    catch (e_6_1) { e_6 = { error: e_6_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_6) throw e_6.error; }
                    }
                    break;
                case "literal":
                    try {
                        for (var _g = (e_7 = void 0, __values(definition.checks)), _h = _g.next(); !_h.done; _h = _g.next()) {
                            var type_2 = _h.value;
                            isValid = isValid || value === type_2;
                            expectedTypes.push(typeof type_2 === "string" ? "\"" + type_2 + "\"" : "" + type_2);
                        }
                    }
                    catch (e_7_1) { e_7 = { error: e_7_1 }; }
                    finally {
                        try {
                            if (_h && !_h.done && (_c = _g.return)) _c.call(_g);
                        }
                        finally { if (e_7) throw e_7.error; }
                    }
                    break;
                case "custom":
                    try {
                        for (var _j = (e_8 = void 0, __values(definition.checks)), _k = _j.next(); !_k.done; _k = _j.next()) {
                            var check = _k.value;
                            var _l = __read(check(value), 3), checkPassed = _l[0], typeDescription = _l[1], receivedType_1 = _l[2];
                            isValid = isValid || checkPassed;
                            if (!customReceivedType && receivedType_1) {
                                customReceivedType = receivedType_1;
                            }
                            if (typeDescription) {
                                expectedTypes.push(typeDescription);
                            }
                        }
                    }
                    catch (e_8_1) { e_8 = { error: e_8_1 }; }
                    finally {
                        try {
                            if (_k && !_k.done && (_d = _j.return)) _d.call(_j);
                        }
                        finally { if (e_8) throw e_8.error; }
                    }
                    break;
            }
        }
    }
    catch (e_5_1) { e_5 = { error: e_5_1 }; }
    finally {
        try {
            if (ruleDefinitions_1_1 && !ruleDefinitions_1_1.done && (_a = ruleDefinitions_1.return)) _a.call(ruleDefinitions_1);
        }
        finally { if (e_5) throw e_5.error; }
    }
    if (isValid) {
        return [true];
    }
    var receivedType = customReceivedType || stringifyReceivedType(value);
    var lastIndex = expectedTypes.length - 1;
    var expectedTypesString = lastIndex > 0
        ? expectedTypes.slice(0, lastIndex).join(", ") + " or " + expectedTypes[lastIndex]
        : expectedTypes.join(", ");
    return [false, receivedType, expectedTypesString, lastIndex > 1 ? ";" : ","];
};

exports.custom = custom;
exports.literal = literal;
exports.nonEmptyString = nonEmptyString;
exports.nonNegativeInteger = nonNegativeInteger;
exports.objectSchema = objectSchema;
exports.pureObject = pureObject;
exports.runtimeTypeValidation = runtimeTypeValidation;
exports.stringifyReceivedType = stringifyReceivedType;
exports.type = type;
exports.validateTypes = validateTypes;
exports.validateTypesAsync = validateTypesAsync;
//# sourceMappingURL=index.js.map
