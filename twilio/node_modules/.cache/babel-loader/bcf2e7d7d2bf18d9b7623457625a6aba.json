{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clone = exports.objectType = exports.hasOwnProperty = void 0;\nexports.hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction objectType(object) {\n  if (object === undefined) {\n    return 'undefined';\n  }\n\n  if (object === null) {\n    return 'null';\n  }\n\n  if (Array.isArray(object)) {\n    return 'array';\n  }\n\n  return typeof object;\n}\n\nexports.objectType = objectType;\n/**\nRecursively copy a value.\n\n@param source - should be a JavaScript primitive, Array, or (plain old) Object.\n@returns copy of source where every Array and Object have been recursively\n         reconstructed from their constituent elements\n*/\n\nfunction clone(source) {\n  // loose-equality checking for null is faster than strict checking for each of null/undefined/true/false\n  // checking null first, then calling typeof, is faster than vice-versa\n  if (source == null || typeof source != 'object') {\n    // short-circuiting is faster than a single return\n    return source;\n  } // x.constructor == Array is the fastest way to check if x is an Array\n\n\n  if (source.constructor == Array) {\n    // construction via imperative for-loop is faster than source.map(arrayVsObject)\n    var length_1 = source.length; // setting the Array length during construction is faster than just `[]` or `new Array()`\n\n    var arrayTarget = new Array(length_1);\n\n    for (var i = 0; i < length_1; i++) {\n      arrayTarget[i] = clone(source[i]);\n    }\n\n    return arrayTarget;\n  } // Object\n\n\n  var objectTarget = {}; // declaring the variable (with const) inside the loop is faster\n\n  for (var key in source) {\n    // hasOwnProperty costs a bit of performance, but it's semantically necessary\n    // using a global helper is MUCH faster than calling source.hasOwnProperty(key)\n    if (exports.hasOwnProperty.call(source, key)) {\n      objectTarget[key] = clone(source[key]);\n    }\n  }\n\n  return objectTarget;\n}\n\nexports.clone = clone;","map":{"version":3,"sources":["/Users/abdulkhan/Documents/waymax/Waymax/node_modules/rfc6902/util.js"],"names":["Object","defineProperty","exports","value","clone","objectType","hasOwnProperty","prototype","object","undefined","Array","isArray","source","constructor","length_1","length","arrayTarget","i","objectTarget","key","call"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,KAAR,GAAgBF,OAAO,CAACG,UAAR,GAAqBH,OAAO,CAACI,cAAR,GAAyB,KAAK,CAAnE;AACAJ,OAAO,CAACI,cAAR,GAAyBN,MAAM,CAACO,SAAP,CAAiBD,cAA1C;;AACA,SAASD,UAAT,CAAoBG,MAApB,EAA4B;AACxB,MAAIA,MAAM,KAAKC,SAAf,EAA0B;AACtB,WAAO,WAAP;AACH;;AACD,MAAID,MAAM,KAAK,IAAf,EAAqB;AACjB,WAAO,MAAP;AACH;;AACD,MAAIE,KAAK,CAACC,OAAN,CAAcH,MAAd,CAAJ,EAA2B;AACvB,WAAO,OAAP;AACH;;AACD,SAAO,OAAOA,MAAd;AACH;;AACDN,OAAO,CAACG,UAAR,GAAqBA,UAArB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,KAAT,CAAeQ,MAAf,EAAuB;AACnB;AACA;AACA,MAAIA,MAAM,IAAI,IAAV,IAAkB,OAAOA,MAAP,IAAiB,QAAvC,EAAiD;AAC7C;AACA,WAAOA,MAAP;AACH,GANkB,CAOnB;;;AACA,MAAIA,MAAM,CAACC,WAAP,IAAsBH,KAA1B,EAAiC;AAC7B;AACA,QAAII,QAAQ,GAAGF,MAAM,CAACG,MAAtB,CAF6B,CAG7B;;AACA,QAAIC,WAAW,GAAG,IAAIN,KAAJ,CAAUI,QAAV,CAAlB;;AACA,SAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,QAApB,EAA8BG,CAAC,EAA/B,EAAmC;AAC/BD,MAAAA,WAAW,CAACC,CAAD,CAAX,GAAiBb,KAAK,CAACQ,MAAM,CAACK,CAAD,CAAP,CAAtB;AACH;;AACD,WAAOD,WAAP;AACH,GAjBkB,CAkBnB;;;AACA,MAAIE,YAAY,GAAG,EAAnB,CAnBmB,CAoBnB;;AACA,OAAK,IAAIC,GAAT,IAAgBP,MAAhB,EAAwB;AACpB;AACA;AACA,QAAIV,OAAO,CAACI,cAAR,CAAuBc,IAAvB,CAA4BR,MAA5B,EAAoCO,GAApC,CAAJ,EAA8C;AAC1CD,MAAAA,YAAY,CAACC,GAAD,CAAZ,GAAoBf,KAAK,CAACQ,MAAM,CAACO,GAAD,CAAP,CAAzB;AACH;AACJ;;AACD,SAAOD,YAAP;AACH;;AACDhB,OAAO,CAACE,KAAR,GAAgBA,KAAhB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.clone = exports.objectType = exports.hasOwnProperty = void 0;\nexports.hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction objectType(object) {\n    if (object === undefined) {\n        return 'undefined';\n    }\n    if (object === null) {\n        return 'null';\n    }\n    if (Array.isArray(object)) {\n        return 'array';\n    }\n    return typeof object;\n}\nexports.objectType = objectType;\n/**\nRecursively copy a value.\n\n@param source - should be a JavaScript primitive, Array, or (plain old) Object.\n@returns copy of source where every Array and Object have been recursively\n         reconstructed from their constituent elements\n*/\nfunction clone(source) {\n    // loose-equality checking for null is faster than strict checking for each of null/undefined/true/false\n    // checking null first, then calling typeof, is faster than vice-versa\n    if (source == null || typeof source != 'object') {\n        // short-circuiting is faster than a single return\n        return source;\n    }\n    // x.constructor == Array is the fastest way to check if x is an Array\n    if (source.constructor == Array) {\n        // construction via imperative for-loop is faster than source.map(arrayVsObject)\n        var length_1 = source.length;\n        // setting the Array length during construction is faster than just `[]` or `new Array()`\n        var arrayTarget = new Array(length_1);\n        for (var i = 0; i < length_1; i++) {\n            arrayTarget[i] = clone(source[i]);\n        }\n        return arrayTarget;\n    }\n    // Object\n    var objectTarget = {};\n    // declaring the variable (with const) inside the loop is faster\n    for (var key in source) {\n        // hasOwnProperty costs a bit of performance, but it's semantically necessary\n        // using a global helper is MUCH faster than calling source.hasOwnProperty(key)\n        if (exports.hasOwnProperty.call(source, key)) {\n            objectTarget[key] = clone(source[key]);\n        }\n    }\n    return objectTarget;\n}\nexports.clone = clone;\n"]},"metadata":{},"sourceType":"script"}