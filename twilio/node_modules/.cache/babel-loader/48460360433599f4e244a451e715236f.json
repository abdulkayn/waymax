{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst sanitize_1 = require(\"./utils/sanitize\");\n\nconst uri_1 = require(\"./utils/uri\");\n\nconst syncerror_1 = require(\"./utils/syncerror\");\n\nconst logger_1 = require(\"./utils/logger\");\n\nconst entity_1 = require(\"./entity\");\n\nconst mapitem_1 = require(\"./mapitem\");\n\nconst paginator_1 = require(\"./paginator\");\n\nconst cache_1 = require(\"./cache\");\n\nconst mergingqueue_1 = require(\"./mergingqueue\");\n\nconst closeable_1 = require(\"./closeable\");\n\nclass SyncMapImpl extends entity_1.SyncEntity {\n  /**\n   * @private\n   */\n  constructor(services, descriptor, removalHandler) {\n    super(services, removalHandler);\n\n    const updateRequestReducer = (acc, input) => typeof input.ttl === 'number' ? {\n      ttl: input.ttl\n    } : acc;\n\n    this.updateMergingQueue = new mergingqueue_1.NamespacedMergingQueue(updateRequestReducer);\n    this.cache = new cache_1.Cache();\n    this.descriptor = descriptor;\n    this.descriptor.date_updated = new Date(this.descriptor.date_updated);\n\n    if (descriptor.items) {\n      descriptor.items.forEach(itemDescriptor => {\n        itemDescriptor.date_updated = new Date(itemDescriptor.date_updated);\n        this.cache.store(itemDescriptor.key, new mapitem_1.MapItem(itemDescriptor), itemDescriptor.last_event_id);\n      });\n    }\n  } // private props\n\n\n  get uri() {\n    return this.descriptor.url;\n  }\n\n  get links() {\n    return this.descriptor.links;\n  }\n\n  get revision() {\n    return this.descriptor.revision;\n  }\n\n  get lastEventId() {\n    return this.descriptor.last_event_id;\n  }\n\n  get dateExpires() {\n    return this.descriptor.date_expires;\n  }\n\n  static get type() {\n    return 'map';\n  }\n\n  get type() {\n    return 'map';\n  } // below properties are specific to Insights only\n\n\n  get indexName() {\n    return undefined;\n  }\n\n  get queryString() {\n    return undefined;\n  } // public props, documented along with class description\n\n\n  get sid() {\n    return this.descriptor.sid;\n  }\n\n  get uniqueName() {\n    return this.descriptor.unique_name || null;\n  }\n\n  get dateUpdated() {\n    return this.descriptor.date_updated;\n  }\n\n  async set(key, value, itemMetadataUpdates) {\n    const input = itemMetadataUpdates || {};\n    sanitize_1.validateOptionalTtl(input.ttl);\n    return this.updateMergingQueue.squashAndAdd(key, input, input => this._putItemUnconditionally(key, value, input.ttl));\n  }\n\n  async get(key) {\n    if (key === null || key === undefined) {\n      throw new syncerror_1.SyncError('Item key may not be empty', 400, 54209);\n    }\n\n    if (this.cache.has(key)) {\n      return this.cache.get(key);\n    } else {\n      return this._getItemFromServer(key);\n    }\n  }\n\n  async _getItemFromServer(key) {\n    let result = await this.queryItems({\n      key: key\n    });\n\n    if (result.items.length < 1) {\n      throw new syncerror_1.SyncError(\"The specified Map Item does not exist\", 404, 54201);\n    } else {\n      return result.items[0];\n    }\n  }\n\n  async mutate(key, mutator, itemMetadataUpdates) {\n    const input = itemMetadataUpdates || {};\n    sanitize_1.validateOptionalTtl(input.ttl);\n    return this.updateMergingQueue.add(key, input, input => this._putItemWithIfMatch(key, mutator, input.ttl));\n  }\n\n  async update(key, obj, itemMetadataUpdates) {\n    return this.mutate(key, remote => Object.assign(remote, obj), itemMetadataUpdates);\n  }\n\n  async _putItemUnconditionally(key, data, ttl) {\n    const result = await this._putItemToServer(key, data, undefined, ttl);\n    const item = result.item;\n\n    this._handleItemMutated(item.key, item.url, item.last_event_id, item.revision, item.data, item.date_updated, item.date_expires, result.added, false);\n\n    return this.cache.get(item.key);\n  }\n\n  async _putItemWithIfMatch(key, mutatorFunction, ttl) {\n    const currentItem = await this.get(key).catch(error => {\n      if (error.status === 404) {\n        // PUT /Items/myKey with `If-Match: -1` acts as \"put if not exists\"\n        return new mapitem_1.MapItem({\n          key: key,\n          data: {},\n          last_event_id: -1,\n          revision: '-1',\n          url: null,\n          date_updated: null,\n          date_expires: null\n        });\n      } else {\n        throw error;\n      }\n    });\n    let data = mutatorFunction(sanitize_1.deepClone(currentItem.data));\n\n    if (data) {\n      let ifMatch = currentItem.revision;\n\n      try {\n        const result = await this._putItemToServer(key, data, ifMatch, ttl);\n        const item = result.item;\n\n        this._handleItemMutated(item.key, item.url, item.last_event_id, item.revision, item.data, item.date_updated, item.date_expires, result.added, false);\n\n        return this.cache.get(item.key);\n      } catch (error) {\n        if (error.status === 412) {\n          await this._getItemFromServer(key);\n          return this._putItemWithIfMatch(key, mutatorFunction, ttl);\n        } else {\n          throw error;\n        }\n      }\n    } else {\n      return currentItem;\n    }\n  }\n\n  async _putItemToServer(key, data, ifMatch, ttl) {\n    const url = new uri_1.UriBuilder(this.links.items).pathSegment(key).build();\n    const requestBody = {\n      data\n    };\n\n    if (ttl !== undefined) {\n      requestBody.ttl = ttl;\n    }\n\n    try {\n      const response = await this.services.network.put(url, requestBody, ifMatch);\n      const mapItemDescriptor = response.body;\n      mapItemDescriptor.data = data; // The server does not return the data in the response\n\n      mapItemDescriptor.date_updated = new Date(mapItemDescriptor.date_updated);\n      const added = response.status.code === 201;\n      return {\n        added,\n        item: mapItemDescriptor\n      };\n    } catch (error) {\n      if (error.status === 404) {\n        this.onRemoved(false);\n      }\n\n      throw error;\n    }\n  }\n\n  async remove(key) {\n    const item = await this.get(key);\n    const previousItemData = sanitize_1.deepClone(item.data);\n    const response = await this.services.network.delete(item.uri);\n\n    this._handleItemRemoved(key, response.body.last_event_id, previousItemData, new Date(response.body.date_updated), false);\n  }\n  /**\n   * @private\n   */\n\n\n  async queryItems(args) {\n    args = args || {};\n    const uri = new uri_1.UriBuilder(this.links.items).queryParam('From', args.from).queryParam('PageSize', args.limit).queryParam('Key', args.key).queryParam('PageToken', args.pageToken).queryParam('Order', args.order).build();\n    let response = await this.services.network.get(uri);\n    let items = response.body.items.map(el => {\n      el.date_updated = new Date(el.date_updated);\n      let itemInCache = this.cache.get(el.key);\n\n      if (itemInCache) {\n        this._handleItemMutated(el.key, el.url, el.last_event_id, el.revision, el.data, el.date_updated, el.date_expires, false, true);\n      } else {\n        this.cache.store(el.key, new mapitem_1.MapItem(el), el.last_event_id);\n      }\n\n      return this.cache.get(el.key);\n    });\n    const meta = response.body.meta;\n    return new paginator_1.Paginator(items, pageToken => this.queryItems({\n      pageToken\n    }), meta.previous_token, meta.next_token);\n  }\n\n  async getItems(args) {\n    args = args || {};\n    sanitize_1.validatePageSize(args.pageSize);\n    args.limit = args.pageSize || args.limit || 50;\n    args.order = args.order || 'asc';\n    return this.queryItems(args);\n  }\n\n  shouldIgnoreEvent(key, eventId) {\n    return this.cache.isKnown(key, eventId);\n  }\n  /**\n   * Handle update from the server\n   * @private\n   */\n\n\n  _update(update, isStrictlyOrdered) {\n    update.date_created = new Date(update.date_created);\n\n    switch (update.type) {\n      case 'map_item_added':\n      case 'map_item_updated':\n        {\n          this._handleItemMutated(update.item_key, update.item_url, update.id, update.item_revision, update.item_data, update.date_created, undefined, // orchestration events do not include date_expires\n          update.type === 'map_item_added', true);\n        }\n        break;\n\n      case 'map_item_removed':\n        {\n          this._handleItemRemoved(update.item_key, update.id, update.item_data, update.date_created, true);\n        }\n        break;\n\n      case 'map_removed':\n        {\n          this.onRemoved(false);\n        }\n        break;\n    }\n\n    if (isStrictlyOrdered) {\n      this._advanceLastEventId(update.id, update.map_revision);\n    }\n  }\n\n  _advanceLastEventId(eventId, revision) {\n    if (this.lastEventId < eventId) {\n      this.descriptor.last_event_id = eventId;\n\n      if (revision) {\n        this.descriptor.revision = revision;\n      }\n    }\n  }\n\n  _updateRootDateUpdated(dateUpdated) {\n    if (!this.descriptor.date_updated || dateUpdated.getTime() > this.descriptor.date_updated.getTime()) {\n      this.descriptor.date_updated = dateUpdated;\n      this.services.storage.update(this.type, this.sid, this.uniqueName, {\n        date_updated: dateUpdated\n      });\n    }\n  }\n\n  _handleItemMutated(key, url, lastEventId, revision, data, dateUpdated, dateExpires, added, remote) {\n    if (this.shouldIgnoreEvent(key, lastEventId)) {\n      logger_1.default.trace('Item ', key, ' update skipped, current:', this.lastEventId, ', remote:', lastEventId);\n      return;\n    }\n\n    this._updateRootDateUpdated(dateUpdated);\n\n    const item = this.cache.get(key);\n\n    if (!item) {\n      const newItem = new mapitem_1.MapItem({\n        key: key,\n        url,\n        last_event_id: lastEventId,\n        revision,\n        data,\n        date_updated: dateUpdated,\n        date_expires: dateExpires\n      });\n      this.cache.store(key, newItem, lastEventId);\n      this.emitItemMutationEvent(newItem, remote, added);\n      return;\n    }\n\n    const previousItemData = sanitize_1.deepClone(item.data);\n    item.update(lastEventId, revision, data, dateUpdated);\n    this.cache.store(key, item, lastEventId);\n\n    if (dateExpires !== undefined) {\n      item.updateDateExpires(dateExpires);\n    }\n\n    this.emitItemMutationEvent(item, remote, false, previousItemData);\n  }\n\n  emitItemMutationEvent(item, remote, added) {\n    let previousItemData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    const eventName = added ? 'itemAdded' : 'itemUpdated';\n    const args = {\n      item,\n      isLocal: !remote\n    };\n\n    if (!added) {\n      args.previousItemData = previousItemData;\n    }\n\n    this.broadcastEventToListeners(eventName, args);\n  }\n  /**\n   * @private\n   */\n\n\n  _handleItemRemoved(key, eventId, oldData, dateUpdated, remote) {\n    this._updateRootDateUpdated(dateUpdated);\n\n    this.cache.delete(key, eventId);\n    this.broadcastEventToListeners('itemRemoved', {\n      key: key,\n      isLocal: !remote,\n      previousItemData: oldData\n    });\n  }\n\n  onRemoved(locally) {\n    this._unsubscribe();\n\n    this.removalHandler(this.type, this.sid, this.uniqueName);\n    this.broadcastEventToListeners('removed', {\n      isLocal: locally\n    });\n  }\n\n  async setTtl(ttl) {\n    sanitize_1.validateMandatoryTtl(ttl);\n\n    try {\n      const requestBody = {\n        ttl\n      };\n      const response = await this.services.network.post(this.uri, requestBody);\n      this.descriptor.date_expires = response.body.date_expires;\n    } catch (error) {\n      if (error.status === 404) {\n        this.onRemoved(false);\n      }\n\n      throw error;\n    }\n  }\n\n  async setItemTtl(key, ttl) {\n    sanitize_1.validateMandatoryTtl(ttl);\n    let existingItem = await this.get(key);\n    const requestBody = {\n      ttl\n    };\n    const response = await this.services.network.post(existingItem.uri, requestBody);\n    existingItem.updateDateExpires(response.body.date_expires);\n  }\n\n  async removeMap() {\n    await this.services.network.delete(this.uri);\n    this.onRemoved(true);\n  }\n\n}\n\nexports.SyncMapImpl = SyncMapImpl;\n/**\n * @class\n * @alias Map\n * @classdesc Represents a Sync Map, which stores an unordered set of key:value pairs.\n * Use the {@link Client#map} method to obtain a reference to a Sync Map.\n * Information about rate limits can be found {@link https://www.twilio.com/docs/sync/limits|here}.\n * @property {String} sid An immutable identifier (a SID) assigned by the system on creation.\n * @property {String} [uniqueName=null] - An optional immutable identifier that may be assigned by the\n * programmer to this map on creation. Unique among other Maps.\n * @property {Date} dateUpdated Date when the Map was last updated.\n *\n * @fires Map#removed\n * @fires Map#itemAdded\n * @fires Map#itemRemoved\n * @fires Map#itemUpdated\n */\n\nclass SyncMap extends closeable_1.Closeable {\n  constructor(syncMapImpl) {\n    super();\n    this.syncMapImpl = syncMapImpl;\n    this.syncMapImpl.attach(this);\n  } // private props\n\n\n  get uri() {\n    return this.syncMapImpl.uri;\n  }\n\n  get links() {\n    return this.syncMapImpl.links;\n  }\n\n  get revision() {\n    return this.syncMapImpl.revision;\n  }\n\n  get lastEventId() {\n    return this.syncMapImpl.lastEventId;\n  }\n\n  get dateExpires() {\n    return this.syncMapImpl.dateExpires;\n  }\n\n  static get type() {\n    return SyncMapImpl.type;\n  }\n\n  get type() {\n    return SyncMapImpl.type;\n  } // public props, documented along with class description\n\n\n  get sid() {\n    return this.syncMapImpl.sid;\n  }\n\n  get uniqueName() {\n    return this.syncMapImpl.uniqueName;\n  }\n\n  get dateUpdated() {\n    return this.syncMapImpl.dateUpdated;\n  }\n  /**\n   * Add a new item to the map with the given key:value pair. Overwrites any data that might already exist at that key.\n   * @param {String} key Unique item identifier.\n   * @param {Object} data Data to be set.\n   * @param {Map#ItemMetadata} [itemMetadataUpdates] New item metadata.\n   * @returns {Promise<MapItem>} Newly added item, or modified one if already exists, with the latest known data.\n   * @public\n   * @example\n   * map.set('myKey', { name: 'John Smith' }, { ttl: 86400 })\n   *   .then(function(item) {\n   *     console.log('Map Item set() successful, item data:', item.data);\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Map Item set() failed', error);\n   *   });\n   */\n\n\n  async set(key, data, itemMetadataUpdates) {\n    this.ensureNotClosed();\n    return this.syncMapImpl.set(key, data, itemMetadataUpdates);\n  }\n  /**\n   * Retrieve an item by key.\n   * @param {String} key Identifies the desired item.\n   * @returns {Promise<MapItem>} A promise that resolves when the item has been fetched.\n   * This promise will be rejected if item was not found.\n   * @public\n   * @example\n   * map.get('myKey')\n   *   .then(function(item) {\n   *     console.log('Map Item get() successful, item data:', item.data)\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Map Item get() failed', error);\n   *   });\n   */\n\n\n  async get(key) {\n    this.ensureNotClosed();\n    return this.syncMapImpl.get(key);\n  }\n  /**\n   * Schedules a modification to this Map Item that will apply a mutation function.\n   * If no Item with the given key exists, it will first be created, having the default data (<code>{}</code>).\n   * @param {String} key Selects the map item to be mutated.\n   * @param {Map~Mutator} mutator A function that outputs a new data based on the existing data.\n   * May be called multiple times, particularly if this Map Item is modified concurrently by remote code.\n   * If the mutation ultimately succeeds, the Map Item will have made the particular transition described\n   * by this function.\n   * @param {Map#ItemMetadata} [itemMetadataUpdates] New item metadata.\n   * @returns {Promise<MapItem>} Resolves with the most recent item state, the output of a successful\n   * mutation or a state that prompted graceful cancellation (mutator returned <code>null</code>).\n   * @public\n   * @example\n   * var mutatorFunction = function(currentData) {\n   *     currentData.viewCount = (currentData.viewCount || 0) + 1;\n   *     return currentData;\n   * };\n   * map.mutate('myKey', mutatorFunction, { ttl: 86400 })\n   *   .then(function(item) {\n   *     console.log('Map Item mutate() successful, new data:', item.data)\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Map Item mutate() failed', error);\n   *   });\n   */\n\n\n  async mutate(key, mutator, itemMetadataUpdates) {\n    this.ensureNotClosed();\n    return this.syncMapImpl.mutate(key, mutator, itemMetadataUpdates);\n  }\n  /**\n   * Modify a map item by appending new fields (or by overwriting existing ones) with the values from\n   * the provided Object. Creates a new item if no item by this key exists, copying all given fields and values\n   * into it.\n   * This is equivalent to\n   * <pre>\n   * map.mutate('myKey', function(currentData) {\n   *   return Object.assign(currentData, obj));\n   * });\n   * </pre>\n   * @param {String} key Selects the map item to update.\n   * @param {Object} obj Specifies the particular (top-level) attributes that will receive new values.\n   * @param {Map#ItemMetadata} [itemMetadataUpdates] New item metadata.\n   * @returns {Promise<MapItem>} A promise resolving to the modified item in its new state.\n   * @public\n   * @example\n   * // Say, the Map Item (key: 'myKey') data is { name: 'John Smith' }\n   * map.update('myKey', { age: 34 }, { ttl: 86400 })\n   *   .then(function(item) {\n   *     // Now the Map Item data is { name: 'John Smith', age: 34 }\n   *     console.log('Map Item update() successful, new data:', item.data);\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Map Item update() failed', error);\n   *   });\n   */\n\n\n  async update(key, obj, itemMetadataUpdates) {\n    this.ensureNotClosed();\n    return this.syncMapImpl.update(key, obj, itemMetadataUpdates);\n  }\n  /**\n   * Delete an item, given its key.\n   * @param {String} key Selects the item to delete.\n   * @returns {Promise<void>} A promise to remove an item.\n   * The promise will be rejected if 'key' is undefined or an item was not found.\n   * @public\n   * @example\n   * map.remove('myKey')\n   *   .then(function() {\n   *     console.log('Map Item remove() successful');\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Map Item remove() failed', error);\n   *   });\n   */\n\n\n  async remove(key) {\n    this.ensureNotClosed();\n    return this.syncMapImpl.remove(key);\n  }\n  /**\n   * Get a complete list of items from the map.\n   * Information about the query limits can be found {@link https://www.twilio.com/docs/sync/limits|here}.\n   * @param {Object} [queryOptions] Arguments for query.\n   * @param {String} [queryOptions.from] Item key, which should be used as the offset. If undefined, starts from the beginning or end depending on\n   * queryOptions.order.\n   * @param {Number} [queryOptions.pageSize=50] Result page size.\n   * @param {'asc'|'desc'} [queryOptions.order='asc'] Lexicographical order of results.\n   * @return {Promise<Paginator<MapItem>>}\n   * @public\n   * @example\n   * var pageHandler = function(paginator) {\n   *   paginator.items.forEach(function(item) {\n   *     console.log('Item ' + item.key + ': ', item.data);\n   *   });\n   *   return paginator.hasNextPage ? paginator.nextPage().then(pageHandler)\n   *                                : null;\n   * };\n   * map.getItems({ from: 'myKey', order: 'asc' })\n   *   .then(pageHandler)\n   *   .catch(function(error) {\n   *     console.error('Map getItems() failed', error);\n   *   });\n   */\n\n\n  async getItems(queryOptions) {\n    this.ensureNotClosed();\n    return this.syncMapImpl.getItems(queryOptions);\n  }\n  /**\n   * Update the time-to-live of the map.\n   * @param {Number} ttl Specifies the TTL in seconds after which the map is subject to automatic deletion. The value 0 means infinity.\n   * @return {Promise<void>} A promise that resolves after the TTL update was successful.\n   * @public\n   * @example\n   * map.setTtl(3600)\n   *   .then(function() {\n   *     console.log('Map setTtl() successful');\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Map setTtl() failed', error);\n   *   });\n   */\n\n\n  async setTtl(ttl) {\n    this.ensureNotClosed();\n    return this.syncMapImpl.setTtl(ttl);\n  }\n  /**\n   * Update the time-to-live of a map item.\n   * @param {Number} key Item key.\n   * @param {Number} ttl Specifies the TTL in seconds after which the map item is subject to automatic deletion. The value 0 means infinity.\n   * @return {Promise<void>} A promise that resolves after the TTL update was successful.\n   * @public\n   * @example\n   * map.setItemTtl('myKey', 86400)\n   *   .then(function() {\n   *     console.log('Map setItemTtl() successful');\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Map setItemTtl() failed', error);\n   *   });\n   */\n\n\n  async setItemTtl(key, ttl) {\n    this.ensureNotClosed();\n    return this.syncMapImpl.setItemTtl(key, ttl);\n  }\n  /**\n   * Delete this map. It will be impossible to restore it.\n   * @return {Promise<void>} A promise that resolves when the map has been deleted.\n   * @public\n   * @example\n   * map.removeMap()\n   *   .then(function() {\n   *     console.log('Map removeMap() successful');\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Map removeMap() failed', error);\n   *   });\n   */\n\n\n  async removeMap() {\n    this.ensureNotClosed();\n    await this.syncMapImpl.removeMap();\n  }\n  /**\n   * Conclude work with the map instance and remove all event listeners attached to it.\n   * Any subsequent operation on this object will be rejected with error.\n   * Other local copies of this map will continue operating and receiving events normally.\n   * @public\n   * @example\n   * map.close();\n   */\n\n\n  close() {\n    super.close();\n    this.syncMapImpl.detach(this.listenerUuid);\n  }\n\n}\n\nexports.SyncMap = SyncMap;\nexports.default = SyncMap;\n/**\n * Contains Map Item metadata.\n * @typedef {Object} Map#ItemMetadata\n * @property {Number} [ttl] Specifies the time-to-live in seconds after which the map item is subject to automatic deletion.\n * The value 0 means infinity.\n */\n\n/**\n * Applies a transformation to the item data. May be called multiple times on the\n * same datum in case of collisions with remote code.\n * @callback Map~Mutator\n * @param {Object} currentData The current data of the item in the cloud.\n * @return {Object} The desired new data for the item or <code>null</code> to gracefully cancel the mutation.\n */\n\n/**\n * Fired when a new item appears in the map, whether its creator was local or remote.\n * @event Map#itemAdded\n * @param {Object} args Arguments provided with the event.\n * @param {MapItem} args.item Added item.\n * @param {Boolean} args.isLocal Equals 'true' if item was added by local actor, 'false' otherwise.\n * @example\n * map.on('itemAdded', function(args) {\n *   console.log('Map item ' + args.item.key + ' was added');\n *   console.log('args.item.data:', args.item.data);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n\n/**\n * Fired when a map item is updated (not added or removed, but changed), whether the updater was local or remote.\n * @event Map#itemUpdated\n * @param {Object} args Arguments provided with the event.\n * @param {MapItem} args.item Updated item.\n * @param {Boolean} args.isLocal Equals 'true' if item was updated by local actor, 'false' otherwise.\n * @param {Object} args.previousItemData Contains a snapshot of the item data before the update.\n * @example\n * map.on('itemUpdated', function(args) {\n *   console.log('Map item ' + args.item.key + ' was updated');\n *   console.log('args.item.data:', args.item.data);\n *   console.log('args.isLocal:', args.isLocal);\n *   console.log('args.previousItemData:', args.previousItemData);\n * });\n */\n\n/**\n * Fired when a map item is removed, whether the remover was local or remote.\n * @event Map#itemRemoved\n * @param {Object} args Arguments provided with the event.\n * @param {String} args.key The key of the removed item.\n * @param {Boolean} args.isLocal Equals 'true' if item was removed by local actor, 'false' otherwise.\n * @param {Object} args.previousItemData Contains a snapshot of item data before removal.\n * @example\n * map.on('itemRemoved', function(args) {\n *   console.log('Map item ' + args.key + ' was removed');\n *   console.log('args.previousItemData:', args.previousItemData);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n\n/**\n * Fired when a map is deleted entirely, by any actor local or remote.\n * @event Map#removed\n * @param {Object} args Arguments provided with the event.\n * @param {Boolean} args.isLocal Equals 'true' if map was removed by local actor, 'false' otherwise.\n * @example\n * map.on('removed', function(args) {\n *   console.log('Map ' + map.sid + ' was removed');\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */","map":{"version":3,"sources":["/Users/abdulkhan/Documents/waymax/Waymax/node_modules/twilio-sync/lib/syncmap.js"],"names":["Object","defineProperty","exports","value","sanitize_1","require","uri_1","syncerror_1","logger_1","entity_1","mapitem_1","paginator_1","cache_1","mergingqueue_1","closeable_1","SyncMapImpl","SyncEntity","constructor","services","descriptor","removalHandler","updateRequestReducer","acc","input","ttl","updateMergingQueue","NamespacedMergingQueue","cache","Cache","date_updated","Date","items","forEach","itemDescriptor","store","key","MapItem","last_event_id","uri","url","links","revision","lastEventId","dateExpires","date_expires","type","indexName","undefined","queryString","sid","uniqueName","unique_name","dateUpdated","set","itemMetadataUpdates","validateOptionalTtl","squashAndAdd","_putItemUnconditionally","get","SyncError","has","_getItemFromServer","result","queryItems","length","mutate","mutator","add","_putItemWithIfMatch","update","obj","remote","assign","data","_putItemToServer","item","_handleItemMutated","added","mutatorFunction","currentItem","catch","error","status","deepClone","ifMatch","UriBuilder","pathSegment","build","requestBody","response","network","put","mapItemDescriptor","body","code","onRemoved","remove","previousItemData","delete","_handleItemRemoved","args","queryParam","from","limit","pageToken","order","map","el","itemInCache","meta","Paginator","previous_token","next_token","getItems","validatePageSize","pageSize","shouldIgnoreEvent","eventId","isKnown","_update","isStrictlyOrdered","date_created","item_key","item_url","id","item_revision","item_data","_advanceLastEventId","map_revision","_updateRootDateUpdated","getTime","storage","default","trace","newItem","emitItemMutationEvent","updateDateExpires","eventName","isLocal","broadcastEventToListeners","oldData","locally","_unsubscribe","setTtl","validateMandatoryTtl","post","setItemTtl","existingItem","removeMap","SyncMap","Closeable","syncMapImpl","attach","ensureNotClosed","queryOptions","close","detach","listenerUuid"],"mappings":"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CA;AACA;AACA;AACA;;;AACa,QAAHI,GAAG,CAACvB,GAAD,EAAM;AACX,SAAKsH,eAAL;AACA,WAAO,KAAKF,WAAL,CAAiB7F,GAAjB,CAAqBvB,GAArB,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACgB,QAAN8B,MAAM,CAAC9B,GAAD,EAAM+B,OAAN,EAAeZ,mBAAf,EAAoC;AAC5C,SAAKmG,eAAL;AACA,WAAO,KAAKF,WAAL,CAAiBtF,MAAjB,CAAwB9B,GAAxB,EAA6B+B,OAA7B,EAAsCZ,mBAAtC,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACgB,QAANe,MAAM,CAAClC,GAAD,EAAMmC,GAAN,EAAWhB,mBAAX,EAAgC;AACxC,SAAKmG,eAAL;AACA,WAAO,KAAKF,WAAL,CAAiBlF,MAAjB,CAAwBlC,GAAxB,EAA6BmC,GAA7B,EAAkChB,mBAAlC,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACgB,QAAN0C,MAAM,CAAC7D,GAAD,EAAM;AACd,SAAKsH,eAAL;AACA,WAAO,KAAKF,WAAL,CAAiBvD,MAAjB,CAAwB7D,GAAxB,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACkB,QAAR8E,QAAQ,CAACyC,YAAD,EAAe;AACzB,SAAKD,eAAL;AACA,WAAO,KAAKF,WAAL,CAAiBtC,QAAjB,CAA0ByC,YAA1B,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACgB,QAANX,MAAM,CAACvH,GAAD,EAAM;AACd,SAAKiI,eAAL;AACA,WAAO,KAAKF,WAAL,CAAiBR,MAAjB,CAAwBvH,GAAxB,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACoB,QAAV0H,UAAU,CAAC/G,GAAD,EAAMX,GAAN,EAAW;AACvB,SAAKiI,eAAL;AACA,WAAO,KAAKF,WAAL,CAAiBL,UAAjB,CAA4B/G,GAA5B,EAAiCX,GAAjC,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACmB,QAAT4H,SAAS,GAAG;AACd,SAAKK,eAAL;AACA,UAAM,KAAKF,WAAL,CAAiBH,SAAjB,EAAN;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIO,EAAAA,KAAK,GAAG;AACJ,UAAMA,KAAN;AACA,SAAKJ,WAAL,CAAiBK,MAAjB,CAAwB,KAAKC,YAA7B;AACH;;AAxPuC;;AA0P5C3J,OAAO,CAACmJ,OAAR,GAAkBA,OAAlB;AACAnJ,OAAO,CAACkI,OAAR,GAAkBiB,OAAlB;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst sanitize_1 = require(\"./utils/sanitize\");\nconst uri_1 = require(\"./utils/uri\");\nconst syncerror_1 = require(\"./utils/syncerror\");\nconst logger_1 = require(\"./utils/logger\");\nconst entity_1 = require(\"./entity\");\nconst mapitem_1 = require(\"./mapitem\");\nconst paginator_1 = require(\"./paginator\");\nconst cache_1 = require(\"./cache\");\nconst mergingqueue_1 = require(\"./mergingqueue\");\nconst closeable_1 = require(\"./closeable\");\nclass SyncMapImpl extends entity_1.SyncEntity {\n    /**\n     * @private\n     */\n    constructor(services, descriptor, removalHandler) {\n        super(services, removalHandler);\n        const updateRequestReducer = (acc, input) => (typeof input.ttl === 'number') ? { ttl: input.ttl }\n            : acc;\n        this.updateMergingQueue = new mergingqueue_1.NamespacedMergingQueue(updateRequestReducer);\n        this.cache = new cache_1.Cache();\n        this.descriptor = descriptor;\n        this.descriptor.date_updated = new Date(this.descriptor.date_updated);\n        if (descriptor.items) {\n            descriptor.items.forEach(itemDescriptor => {\n                itemDescriptor.date_updated = new Date(itemDescriptor.date_updated);\n                this.cache.store(itemDescriptor.key, new mapitem_1.MapItem(itemDescriptor), itemDescriptor.last_event_id);\n            });\n        }\n    }\n    // private props\n    get uri() {\n        return this.descriptor.url;\n    }\n    get links() {\n        return this.descriptor.links;\n    }\n    get revision() {\n        return this.descriptor.revision;\n    }\n    get lastEventId() {\n        return this.descriptor.last_event_id;\n    }\n    get dateExpires() {\n        return this.descriptor.date_expires;\n    }\n    static get type() {\n        return 'map';\n    }\n    get type() {\n        return 'map';\n    }\n    // below properties are specific to Insights only\n    get indexName() {\n        return undefined;\n    }\n    get queryString() {\n        return undefined;\n    }\n    // public props, documented along with class description\n    get sid() {\n        return this.descriptor.sid;\n    }\n    get uniqueName() {\n        return this.descriptor.unique_name || null;\n    }\n    get dateUpdated() {\n        return this.descriptor.date_updated;\n    }\n    async set(key, value, itemMetadataUpdates) {\n        const input = itemMetadataUpdates || {};\n        sanitize_1.validateOptionalTtl(input.ttl);\n        return this.updateMergingQueue.squashAndAdd(key, input, (input) => this._putItemUnconditionally(key, value, input.ttl));\n    }\n    async get(key) {\n        if (key === null || key === undefined) {\n            throw new syncerror_1.SyncError('Item key may not be empty', 400, 54209);\n        }\n        if (this.cache.has(key)) {\n            return this.cache.get(key);\n        }\n        else {\n            return this._getItemFromServer(key);\n        }\n    }\n    async _getItemFromServer(key) {\n        let result = await this.queryItems({ key: key });\n        if (result.items.length < 1) {\n            throw new syncerror_1.SyncError(`The specified Map Item does not exist`, 404, 54201);\n        }\n        else {\n            return result.items[0];\n        }\n    }\n    async mutate(key, mutator, itemMetadataUpdates) {\n        const input = itemMetadataUpdates || {};\n        sanitize_1.validateOptionalTtl(input.ttl);\n        return this.updateMergingQueue.add(key, input, (input) => this._putItemWithIfMatch(key, mutator, input.ttl));\n    }\n    async update(key, obj, itemMetadataUpdates) {\n        return this.mutate(key, remote => Object.assign(remote, obj), itemMetadataUpdates);\n    }\n    async _putItemUnconditionally(key, data, ttl) {\n        const result = await this._putItemToServer(key, data, undefined, ttl);\n        const item = result.item;\n        this._handleItemMutated(item.key, item.url, item.last_event_id, item.revision, item.data, item.date_updated, item.date_expires, result.added, false);\n        return this.cache.get(item.key);\n    }\n    async _putItemWithIfMatch(key, mutatorFunction, ttl) {\n        const currentItem = await this.get(key)\n            .catch(error => {\n            if (error.status === 404) {\n                // PUT /Items/myKey with `If-Match: -1` acts as \"put if not exists\"\n                return new mapitem_1.MapItem({ key: key, data: {}, last_event_id: -1, revision: '-1', url: null, date_updated: null, date_expires: null });\n            }\n            else {\n                throw error;\n            }\n        });\n        let data = mutatorFunction(sanitize_1.deepClone(currentItem.data));\n        if (data) {\n            let ifMatch = currentItem.revision;\n            try {\n                const result = await this._putItemToServer(key, data, ifMatch, ttl);\n                const item = result.item;\n                this._handleItemMutated(item.key, item.url, item.last_event_id, item.revision, item.data, item.date_updated, item.date_expires, result.added, false);\n                return this.cache.get(item.key);\n            }\n            catch (error) {\n                if (error.status === 412) {\n                    await this._getItemFromServer(key);\n                    return this._putItemWithIfMatch(key, mutatorFunction, ttl);\n                }\n                else {\n                    throw error;\n                }\n            }\n        }\n        else {\n            return currentItem;\n        }\n    }\n    async _putItemToServer(key, data, ifMatch, ttl) {\n        const url = new uri_1.UriBuilder(this.links.items).pathSegment(key).build();\n        const requestBody = { data };\n        if (ttl !== undefined) {\n            requestBody.ttl = ttl;\n        }\n        try {\n            const response = await this.services.network.put(url, requestBody, ifMatch);\n            const mapItemDescriptor = response.body;\n            mapItemDescriptor.data = data; // The server does not return the data in the response\n            mapItemDescriptor.date_updated = new Date(mapItemDescriptor.date_updated);\n            const added = response.status.code === 201;\n            return { added, item: mapItemDescriptor };\n        }\n        catch (error) {\n            if (error.status === 404) {\n                this.onRemoved(false);\n            }\n            throw error;\n        }\n    }\n    async remove(key) {\n        const item = await this.get(key);\n        const previousItemData = sanitize_1.deepClone(item.data);\n        const response = await this.services.network.delete(item.uri);\n        this._handleItemRemoved(key, response.body.last_event_id, previousItemData, new Date(response.body.date_updated), false);\n    }\n    /**\n     * @private\n     */\n    async queryItems(args) {\n        args = args || {};\n        const uri = new uri_1.UriBuilder(this.links.items)\n            .queryParam('From', args.from)\n            .queryParam('PageSize', args.limit)\n            .queryParam('Key', args.key)\n            .queryParam('PageToken', args.pageToken)\n            .queryParam('Order', args.order)\n            .build();\n        let response = await this.services.network.get(uri);\n        let items = response.body.items.map(el => {\n            el.date_updated = new Date(el.date_updated);\n            let itemInCache = this.cache.get(el.key);\n            if (itemInCache) {\n                this._handleItemMutated(el.key, el.url, el.last_event_id, el.revision, el.data, el.date_updated, el.date_expires, false, true);\n            }\n            else {\n                this.cache.store(el.key, new mapitem_1.MapItem(el), el.last_event_id);\n            }\n            return this.cache.get(el.key);\n        });\n        const meta = response.body.meta;\n        return new paginator_1.Paginator(items, pageToken => this.queryItems({ pageToken }), meta.previous_token, meta.next_token);\n    }\n    async getItems(args) {\n        args = args || {};\n        sanitize_1.validatePageSize(args.pageSize);\n        args.limit = args.pageSize || args.limit || 50;\n        args.order = args.order || 'asc';\n        return this.queryItems(args);\n    }\n    shouldIgnoreEvent(key, eventId) {\n        return this.cache.isKnown(key, eventId);\n    }\n    /**\n     * Handle update from the server\n     * @private\n     */\n    _update(update, isStrictlyOrdered) {\n        update.date_created = new Date(update.date_created);\n        switch (update.type) {\n            case 'map_item_added':\n            case 'map_item_updated':\n                {\n                    this._handleItemMutated(update.item_key, update.item_url, update.id, update.item_revision, update.item_data, update.date_created, undefined, // orchestration events do not include date_expires\n                    update.type === 'map_item_added', true);\n                }\n                break;\n            case 'map_item_removed':\n                {\n                    this._handleItemRemoved(update.item_key, update.id, update.item_data, update.date_created, true);\n                }\n                break;\n            case 'map_removed':\n                {\n                    this.onRemoved(false);\n                }\n                break;\n        }\n        if (isStrictlyOrdered) {\n            this._advanceLastEventId(update.id, update.map_revision);\n        }\n    }\n    _advanceLastEventId(eventId, revision) {\n        if (this.lastEventId < eventId) {\n            this.descriptor.last_event_id = eventId;\n            if (revision) {\n                this.descriptor.revision = revision;\n            }\n        }\n    }\n    _updateRootDateUpdated(dateUpdated) {\n        if (!this.descriptor.date_updated || dateUpdated.getTime() > this.descriptor.date_updated.getTime()) {\n            this.descriptor.date_updated = dateUpdated;\n            this.services.storage.update(this.type, this.sid, this.uniqueName, { date_updated: dateUpdated });\n        }\n    }\n    _handleItemMutated(key, url, lastEventId, revision, data, dateUpdated, dateExpires, added, remote) {\n        if (this.shouldIgnoreEvent(key, lastEventId)) {\n            logger_1.default.trace('Item ', key, ' update skipped, current:', this.lastEventId, ', remote:', lastEventId);\n            return;\n        }\n        this._updateRootDateUpdated(dateUpdated);\n        const item = this.cache.get(key);\n        if (!item) {\n            const newItem = new mapitem_1.MapItem({\n                key: key,\n                url,\n                last_event_id: lastEventId,\n                revision,\n                data,\n                date_updated: dateUpdated,\n                date_expires: dateExpires,\n            });\n            this.cache.store(key, newItem, lastEventId);\n            this.emitItemMutationEvent(newItem, remote, added);\n            return;\n        }\n        const previousItemData = sanitize_1.deepClone(item.data);\n        item.update(lastEventId, revision, data, dateUpdated);\n        this.cache.store(key, item, lastEventId);\n        if (dateExpires !== undefined) {\n            item.updateDateExpires(dateExpires);\n        }\n        this.emitItemMutationEvent(item, remote, false, previousItemData);\n    }\n    emitItemMutationEvent(item, remote, added, previousItemData = null) {\n        const eventName = added ? 'itemAdded' : 'itemUpdated';\n        const args = { item, isLocal: !remote };\n        if (!added) {\n            args.previousItemData = previousItemData;\n        }\n        this.broadcastEventToListeners(eventName, args);\n    }\n    /**\n     * @private\n     */\n    _handleItemRemoved(key, eventId, oldData, dateUpdated, remote) {\n        this._updateRootDateUpdated(dateUpdated);\n        this.cache.delete(key, eventId);\n        this.broadcastEventToListeners('itemRemoved', { key: key, isLocal: !remote, previousItemData: oldData });\n    }\n    onRemoved(locally) {\n        this._unsubscribe();\n        this.removalHandler(this.type, this.sid, this.uniqueName);\n        this.broadcastEventToListeners('removed', { isLocal: locally });\n    }\n    async setTtl(ttl) {\n        sanitize_1.validateMandatoryTtl(ttl);\n        try {\n            const requestBody = { ttl };\n            const response = await this.services.network.post(this.uri, requestBody);\n            this.descriptor.date_expires = response.body.date_expires;\n        }\n        catch (error) {\n            if (error.status === 404) {\n                this.onRemoved(false);\n            }\n            throw error;\n        }\n    }\n    async setItemTtl(key, ttl) {\n        sanitize_1.validateMandatoryTtl(ttl);\n        let existingItem = await this.get(key);\n        const requestBody = { ttl };\n        const response = await this.services.network.post(existingItem.uri, requestBody);\n        existingItem.updateDateExpires(response.body.date_expires);\n    }\n    async removeMap() {\n        await this.services.network.delete(this.uri);\n        this.onRemoved(true);\n    }\n}\nexports.SyncMapImpl = SyncMapImpl;\n/**\n * @class\n * @alias Map\n * @classdesc Represents a Sync Map, which stores an unordered set of key:value pairs.\n * Use the {@link Client#map} method to obtain a reference to a Sync Map.\n * Information about rate limits can be found {@link https://www.twilio.com/docs/sync/limits|here}.\n * @property {String} sid An immutable identifier (a SID) assigned by the system on creation.\n * @property {String} [uniqueName=null] - An optional immutable identifier that may be assigned by the\n * programmer to this map on creation. Unique among other Maps.\n * @property {Date} dateUpdated Date when the Map was last updated.\n *\n * @fires Map#removed\n * @fires Map#itemAdded\n * @fires Map#itemRemoved\n * @fires Map#itemUpdated\n */\nclass SyncMap extends closeable_1.Closeable {\n    constructor(syncMapImpl) {\n        super();\n        this.syncMapImpl = syncMapImpl;\n        this.syncMapImpl.attach(this);\n    }\n    // private props\n    get uri() {\n        return this.syncMapImpl.uri;\n    }\n    get links() {\n        return this.syncMapImpl.links;\n    }\n    get revision() {\n        return this.syncMapImpl.revision;\n    }\n    get lastEventId() {\n        return this.syncMapImpl.lastEventId;\n    }\n    get dateExpires() {\n        return this.syncMapImpl.dateExpires;\n    }\n    static get type() {\n        return SyncMapImpl.type;\n    }\n    get type() {\n        return SyncMapImpl.type;\n    }\n    // public props, documented along with class description\n    get sid() {\n        return this.syncMapImpl.sid;\n    }\n    get uniqueName() {\n        return this.syncMapImpl.uniqueName;\n    }\n    get dateUpdated() {\n        return this.syncMapImpl.dateUpdated;\n    }\n    /**\n     * Add a new item to the map with the given key:value pair. Overwrites any data that might already exist at that key.\n     * @param {String} key Unique item identifier.\n     * @param {Object} data Data to be set.\n     * @param {Map#ItemMetadata} [itemMetadataUpdates] New item metadata.\n     * @returns {Promise<MapItem>} Newly added item, or modified one if already exists, with the latest known data.\n     * @public\n     * @example\n     * map.set('myKey', { name: 'John Smith' }, { ttl: 86400 })\n     *   .then(function(item) {\n     *     console.log('Map Item set() successful, item data:', item.data);\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map Item set() failed', error);\n     *   });\n     */\n    async set(key, data, itemMetadataUpdates) {\n        this.ensureNotClosed();\n        return this.syncMapImpl.set(key, data, itemMetadataUpdates);\n    }\n    /**\n     * Retrieve an item by key.\n     * @param {String} key Identifies the desired item.\n     * @returns {Promise<MapItem>} A promise that resolves when the item has been fetched.\n     * This promise will be rejected if item was not found.\n     * @public\n     * @example\n     * map.get('myKey')\n     *   .then(function(item) {\n     *     console.log('Map Item get() successful, item data:', item.data)\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map Item get() failed', error);\n     *   });\n     */\n    async get(key) {\n        this.ensureNotClosed();\n        return this.syncMapImpl.get(key);\n    }\n    /**\n     * Schedules a modification to this Map Item that will apply a mutation function.\n     * If no Item with the given key exists, it will first be created, having the default data (<code>{}</code>).\n     * @param {String} key Selects the map item to be mutated.\n     * @param {Map~Mutator} mutator A function that outputs a new data based on the existing data.\n     * May be called multiple times, particularly if this Map Item is modified concurrently by remote code.\n     * If the mutation ultimately succeeds, the Map Item will have made the particular transition described\n     * by this function.\n     * @param {Map#ItemMetadata} [itemMetadataUpdates] New item metadata.\n     * @returns {Promise<MapItem>} Resolves with the most recent item state, the output of a successful\n     * mutation or a state that prompted graceful cancellation (mutator returned <code>null</code>).\n     * @public\n     * @example\n     * var mutatorFunction = function(currentData) {\n     *     currentData.viewCount = (currentData.viewCount || 0) + 1;\n     *     return currentData;\n     * };\n     * map.mutate('myKey', mutatorFunction, { ttl: 86400 })\n     *   .then(function(item) {\n     *     console.log('Map Item mutate() successful, new data:', item.data)\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map Item mutate() failed', error);\n     *   });\n     */\n    async mutate(key, mutator, itemMetadataUpdates) {\n        this.ensureNotClosed();\n        return this.syncMapImpl.mutate(key, mutator, itemMetadataUpdates);\n    }\n    /**\n     * Modify a map item by appending new fields (or by overwriting existing ones) with the values from\n     * the provided Object. Creates a new item if no item by this key exists, copying all given fields and values\n     * into it.\n     * This is equivalent to\n     * <pre>\n     * map.mutate('myKey', function(currentData) {\n     *   return Object.assign(currentData, obj));\n     * });\n     * </pre>\n     * @param {String} key Selects the map item to update.\n     * @param {Object} obj Specifies the particular (top-level) attributes that will receive new values.\n     * @param {Map#ItemMetadata} [itemMetadataUpdates] New item metadata.\n     * @returns {Promise<MapItem>} A promise resolving to the modified item in its new state.\n     * @public\n     * @example\n     * // Say, the Map Item (key: 'myKey') data is { name: 'John Smith' }\n     * map.update('myKey', { age: 34 }, { ttl: 86400 })\n     *   .then(function(item) {\n     *     // Now the Map Item data is { name: 'John Smith', age: 34 }\n     *     console.log('Map Item update() successful, new data:', item.data);\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map Item update() failed', error);\n     *   });\n     */\n    async update(key, obj, itemMetadataUpdates) {\n        this.ensureNotClosed();\n        return this.syncMapImpl.update(key, obj, itemMetadataUpdates);\n    }\n    /**\n     * Delete an item, given its key.\n     * @param {String} key Selects the item to delete.\n     * @returns {Promise<void>} A promise to remove an item.\n     * The promise will be rejected if 'key' is undefined or an item was not found.\n     * @public\n     * @example\n     * map.remove('myKey')\n     *   .then(function() {\n     *     console.log('Map Item remove() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map Item remove() failed', error);\n     *   });\n     */\n    async remove(key) {\n        this.ensureNotClosed();\n        return this.syncMapImpl.remove(key);\n    }\n    /**\n     * Get a complete list of items from the map.\n     * Information about the query limits can be found {@link https://www.twilio.com/docs/sync/limits|here}.\n     * @param {Object} [queryOptions] Arguments for query.\n     * @param {String} [queryOptions.from] Item key, which should be used as the offset. If undefined, starts from the beginning or end depending on\n     * queryOptions.order.\n     * @param {Number} [queryOptions.pageSize=50] Result page size.\n     * @param {'asc'|'desc'} [queryOptions.order='asc'] Lexicographical order of results.\n     * @return {Promise<Paginator<MapItem>>}\n     * @public\n     * @example\n     * var pageHandler = function(paginator) {\n     *   paginator.items.forEach(function(item) {\n     *     console.log('Item ' + item.key + ': ', item.data);\n     *   });\n     *   return paginator.hasNextPage ? paginator.nextPage().then(pageHandler)\n     *                                : null;\n     * };\n     * map.getItems({ from: 'myKey', order: 'asc' })\n     *   .then(pageHandler)\n     *   .catch(function(error) {\n     *     console.error('Map getItems() failed', error);\n     *   });\n     */\n    async getItems(queryOptions) {\n        this.ensureNotClosed();\n        return this.syncMapImpl.getItems(queryOptions);\n    }\n    /**\n     * Update the time-to-live of the map.\n     * @param {Number} ttl Specifies the TTL in seconds after which the map is subject to automatic deletion. The value 0 means infinity.\n     * @return {Promise<void>} A promise that resolves after the TTL update was successful.\n     * @public\n     * @example\n     * map.setTtl(3600)\n     *   .then(function() {\n     *     console.log('Map setTtl() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map setTtl() failed', error);\n     *   });\n     */\n    async setTtl(ttl) {\n        this.ensureNotClosed();\n        return this.syncMapImpl.setTtl(ttl);\n    }\n    /**\n     * Update the time-to-live of a map item.\n     * @param {Number} key Item key.\n     * @param {Number} ttl Specifies the TTL in seconds after which the map item is subject to automatic deletion. The value 0 means infinity.\n     * @return {Promise<void>} A promise that resolves after the TTL update was successful.\n     * @public\n     * @example\n     * map.setItemTtl('myKey', 86400)\n     *   .then(function() {\n     *     console.log('Map setItemTtl() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map setItemTtl() failed', error);\n     *   });\n     */\n    async setItemTtl(key, ttl) {\n        this.ensureNotClosed();\n        return this.syncMapImpl.setItemTtl(key, ttl);\n    }\n    /**\n     * Delete this map. It will be impossible to restore it.\n     * @return {Promise<void>} A promise that resolves when the map has been deleted.\n     * @public\n     * @example\n     * map.removeMap()\n     *   .then(function() {\n     *     console.log('Map removeMap() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map removeMap() failed', error);\n     *   });\n     */\n    async removeMap() {\n        this.ensureNotClosed();\n        await this.syncMapImpl.removeMap();\n    }\n    /**\n     * Conclude work with the map instance and remove all event listeners attached to it.\n     * Any subsequent operation on this object will be rejected with error.\n     * Other local copies of this map will continue operating and receiving events normally.\n     * @public\n     * @example\n     * map.close();\n     */\n    close() {\n        super.close();\n        this.syncMapImpl.detach(this.listenerUuid);\n    }\n}\nexports.SyncMap = SyncMap;\nexports.default = SyncMap;\n/**\n * Contains Map Item metadata.\n * @typedef {Object} Map#ItemMetadata\n * @property {Number} [ttl] Specifies the time-to-live in seconds after which the map item is subject to automatic deletion.\n * The value 0 means infinity.\n */\n/**\n * Applies a transformation to the item data. May be called multiple times on the\n * same datum in case of collisions with remote code.\n * @callback Map~Mutator\n * @param {Object} currentData The current data of the item in the cloud.\n * @return {Object} The desired new data for the item or <code>null</code> to gracefully cancel the mutation.\n */\n/**\n * Fired when a new item appears in the map, whether its creator was local or remote.\n * @event Map#itemAdded\n * @param {Object} args Arguments provided with the event.\n * @param {MapItem} args.item Added item.\n * @param {Boolean} args.isLocal Equals 'true' if item was added by local actor, 'false' otherwise.\n * @example\n * map.on('itemAdded', function(args) {\n *   console.log('Map item ' + args.item.key + ' was added');\n *   console.log('args.item.data:', args.item.data);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n/**\n * Fired when a map item is updated (not added or removed, but changed), whether the updater was local or remote.\n * @event Map#itemUpdated\n * @param {Object} args Arguments provided with the event.\n * @param {MapItem} args.item Updated item.\n * @param {Boolean} args.isLocal Equals 'true' if item was updated by local actor, 'false' otherwise.\n * @param {Object} args.previousItemData Contains a snapshot of the item data before the update.\n * @example\n * map.on('itemUpdated', function(args) {\n *   console.log('Map item ' + args.item.key + ' was updated');\n *   console.log('args.item.data:', args.item.data);\n *   console.log('args.isLocal:', args.isLocal);\n *   console.log('args.previousItemData:', args.previousItemData);\n * });\n */\n/**\n * Fired when a map item is removed, whether the remover was local or remote.\n * @event Map#itemRemoved\n * @param {Object} args Arguments provided with the event.\n * @param {String} args.key The key of the removed item.\n * @param {Boolean} args.isLocal Equals 'true' if item was removed by local actor, 'false' otherwise.\n * @param {Object} args.previousItemData Contains a snapshot of item data before removal.\n * @example\n * map.on('itemRemoved', function(args) {\n *   console.log('Map item ' + args.key + ' was removed');\n *   console.log('args.previousItemData:', args.previousItemData);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n/**\n * Fired when a map is deleted entirely, by any actor local or remote.\n * @event Map#removed\n * @param {Object} args Arguments provided with the event.\n * @param {Boolean} args.isLocal Equals 'true' if map was removed by local actor, 'false' otherwise.\n * @example\n * map.on('removed', function(args) {\n *   console.log('Map ' + map.sid + ' was removed');\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n"]},"metadata":{},"sourceType":"script"}