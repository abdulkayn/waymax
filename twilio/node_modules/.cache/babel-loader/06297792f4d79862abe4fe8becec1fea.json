{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Connector = exports.RegistrationState = void 0;\n\nconst events_1 = require(\"events\");\n\nconst logger_1 = require(\"./logger\");\n\nclass RegistrationState {\n  constructor() {\n    let token = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    let notificationId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    let messageTypes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();\n    this.token = token;\n    this.notificationId = notificationId;\n    this.messageTypes = messageTypes;\n  }\n\n  clone() {\n    return new RegistrationState(this.token, this.notificationId, new Set(this.messageTypes));\n  }\n\n}\n\nexports.RegistrationState = RegistrationState;\n\nfunction setDifference(a, b) {\n  return [...[...a].filter(x => !b.has(x)), ...[...b].filter(x => !a.has(x))];\n}\n\nfunction hasDifference(a, b) {\n  let reasons = new Set();\n\n  if (a.notificationId !== b.notificationId) {\n    reasons.add('notificationId');\n  }\n\n  if (a.token !== b.token) {\n    reasons.add('token');\n  }\n\n  if (setDifference(a.messageTypes, b.messageTypes).length > 0) {\n    reasons.add('messageType');\n  }\n\n  return [reasons.size > 0, reasons];\n}\n\nclass Connector extends events_1.EventEmitter {\n  constructor(config) {\n    super();\n    this.config = config;\n    this.desiredState = new RegistrationState();\n    this.currentState = new RegistrationState();\n    this.hasActiveAttempt = false;\n  }\n\n  async subscribe(messageType) {\n    if (this.desiredState.messageTypes.has(messageType)) {\n      logger_1.log.debug('message type already registered ', messageType);\n      return;\n    }\n\n    this.desiredState.messageTypes.add(messageType);\n    await this.persistRegistration();\n  }\n\n  async unsubscribe(messageType) {\n    if (!this.desiredState.messageTypes.has(messageType)) {\n      return;\n    }\n\n    this.desiredState.messageTypes.delete(messageType);\n    await this.persistRegistration();\n  }\n\n  updateToken(token) {\n    this.desiredState.token = token;\n    this.persistRegistration();\n  }\n\n  async persistRegistration() {\n    if (!this.config.token || this.config.token.length === 0) {\n      logger_1.log.trace('Can\\'t persist registration: token is not set');\n      return;\n    }\n\n    if (this.hasActiveAttempt) {\n      logger_1.log.trace('One registration attempt is already in progress');\n      return;\n    }\n\n    let [needToUpdate, reasons] = hasDifference(this.desiredState, this.currentState);\n\n    if (!needToUpdate) {\n      return;\n    }\n\n    if (!this.currentState.notificationId) {\n      reasons.delete('notificationId');\n    }\n\n    logger_1.log.trace('Persisting registration', reasons, this.desiredState);\n\n    try {\n      this.hasActiveAttempt = true;\n      let stateToPersist = this.desiredState.clone();\n\n      if (stateToPersist.messageTypes.size > 0) {\n        let persistedState = await this.updateRegistration(stateToPersist, reasons);\n        this.currentState.token = persistedState.token;\n        this.currentState.notificationId = persistedState.notificationId;\n        this.currentState.messageTypes = persistedState.messageTypes;\n        this.emit('stateChanged', 'registered');\n      } else {\n        await this.removeRegistration();\n        this.currentState.token = stateToPersist.token;\n        this.currentState.notificationId = stateToPersist.notificationId;\n        this.currentState.messageTypes.clear();\n        this.emit('stateChanged', 'unregistered');\n      }\n    } finally {\n      this.hasActiveAttempt = false;\n      setTimeout(() => this.persistRegistration(), 0);\n    }\n  }\n\n  setNotificationId(notificationId) {\n    this.desiredState.notificationId = notificationId;\n    this.persistRegistration();\n  }\n\n}\n\nexports.Connector = Connector;","map":{"version":3,"sources":["/Users/abdulkhan/Documents/waymax/Waymax/node_modules/twilio-notifications/lib/connector.js"],"names":["Object","defineProperty","exports","value","Connector","RegistrationState","events_1","require","logger_1","constructor","token","notificationId","messageTypes","Set","clone","setDifference","a","b","filter","x","has","hasDifference","reasons","add","length","size","EventEmitter","config","desiredState","currentState","hasActiveAttempt","subscribe","messageType","log","debug","persistRegistration","unsubscribe","delete","updateToken","trace","needToUpdate","stateToPersist","persistedState","updateRegistration","emit","removeRegistration","clear","setTimeout","setNotificationId"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,SAAR,GAAoBF,OAAO,CAACG,iBAAR,GAA4B,KAAK,CAArD;;AACA,MAAMC,QAAQ,GAAGC,OAAO,CAAC,QAAD,CAAxB;;AACA,MAAMC,QAAQ,GAAGD,OAAO,CAAC,UAAD,CAAxB;;AACA,MAAMF,iBAAN,CAAwB;AACpBI,EAAAA,WAAW,GAA4D;AAAA,QAA3DC,KAA2D,uEAAnD,EAAmD;AAAA,QAA/CC,cAA+C,uEAA9B,EAA8B;AAAA,QAA1BC,YAA0B,uEAAX,IAAIC,GAAJ,EAAW;AACnE,SAAKH,KAAL,GAAaA,KAAb;AACA,SAAKC,cAAL,GAAsBA,cAAtB;AACA,SAAKC,YAAL,GAAoBA,YAApB;AACH;;AACDE,EAAAA,KAAK,GAAG;AACJ,WAAO,IAAIT,iBAAJ,CAAsB,KAAKK,KAA3B,EAAkC,KAAKC,cAAvC,EAAuD,IAAIE,GAAJ,CAAQ,KAAKD,YAAb,CAAvD,CAAP;AACH;;AARmB;;AAUxBV,OAAO,CAACG,iBAAR,GAA4BA,iBAA5B;;AACA,SAASU,aAAT,CAAuBC,CAAvB,EAA0BC,CAA1B,EAA6B;AACzB,SAAO,CAAC,GAAG,CAAC,GAAGD,CAAJ,EAAOE,MAAP,CAAcC,CAAC,IAAI,CAACF,CAAC,CAACG,GAAF,CAAMD,CAAN,CAApB,CAAJ,EACH,GAAG,CAAC,GAAGF,CAAJ,EAAOC,MAAP,CAAcC,CAAC,IAAI,CAACH,CAAC,CAACI,GAAF,CAAMD,CAAN,CAApB,CADA,CAAP;AAEH;;AACD,SAASE,aAAT,CAAuBL,CAAvB,EAA0BC,CAA1B,EAA6B;AACzB,MAAIK,OAAO,GAAG,IAAIT,GAAJ,EAAd;;AACA,MAAIG,CAAC,CAACL,cAAF,KAAqBM,CAAC,CAACN,cAA3B,EAA2C;AACvCW,IAAAA,OAAO,CAACC,GAAR,CAAY,gBAAZ;AACH;;AACD,MAAIP,CAAC,CAACN,KAAF,KAAYO,CAAC,CAACP,KAAlB,EAAyB;AACrBY,IAAAA,OAAO,CAACC,GAAR,CAAY,OAAZ;AACH;;AACD,MAAIR,aAAa,CAACC,CAAC,CAACJ,YAAH,EAAiBK,CAAC,CAACL,YAAnB,CAAb,CAA8CY,MAA9C,GAAuD,CAA3D,EAA8D;AAC1DF,IAAAA,OAAO,CAACC,GAAR,CAAY,aAAZ;AACH;;AACD,SAAO,CAACD,OAAO,CAACG,IAAR,GAAe,CAAhB,EAAmBH,OAAnB,CAAP;AACH;;AACD,MAAMlB,SAAN,SAAwBE,QAAQ,CAACoB,YAAjC,CAA8C;AAC1CjB,EAAAA,WAAW,CAACkB,MAAD,EAAS;AAChB;AACA,SAAKA,MAAL,GAAcA,MAAd;AACA,SAAKC,YAAL,GAAoB,IAAIvB,iBAAJ,EAApB;AACA,SAAKwB,YAAL,GAAoB,IAAIxB,iBAAJ,EAApB;AACA,SAAKyB,gBAAL,GAAwB,KAAxB;AACH;;AACc,QAATC,SAAS,CAACC,WAAD,EAAc;AACzB,QAAI,KAAKJ,YAAL,CAAkBhB,YAAlB,CAA+BQ,GAA/B,CAAmCY,WAAnC,CAAJ,EAAqD;AACjDxB,MAAAA,QAAQ,CAACyB,GAAT,CAAaC,KAAb,CAAmB,kCAAnB,EAAuDF,WAAvD;AACA;AACH;;AACD,SAAKJ,YAAL,CAAkBhB,YAAlB,CAA+BW,GAA/B,CAAmCS,WAAnC;AACA,UAAM,KAAKG,mBAAL,EAAN;AACH;;AACgB,QAAXC,WAAW,CAACJ,WAAD,EAAc;AAC3B,QAAI,CAAC,KAAKJ,YAAL,CAAkBhB,YAAlB,CAA+BQ,GAA/B,CAAmCY,WAAnC,CAAL,EAAsD;AAClD;AACH;;AACD,SAAKJ,YAAL,CAAkBhB,YAAlB,CAA+ByB,MAA/B,CAAsCL,WAAtC;AACA,UAAM,KAAKG,mBAAL,EAAN;AACH;;AACDG,EAAAA,WAAW,CAAC5B,KAAD,EAAQ;AACf,SAAKkB,YAAL,CAAkBlB,KAAlB,GAA0BA,KAA1B;AACA,SAAKyB,mBAAL;AACH;;AACwB,QAAnBA,mBAAmB,GAAG;AACxB,QAAI,CAAC,KAAKR,MAAL,CAAYjB,KAAb,IAAsB,KAAKiB,MAAL,CAAYjB,KAAZ,CAAkBc,MAAlB,KAA6B,CAAvD,EAA0D;AACtDhB,MAAAA,QAAQ,CAACyB,GAAT,CAAaM,KAAb,CAAmB,+CAAnB;AACA;AACH;;AACD,QAAI,KAAKT,gBAAT,EAA2B;AACvBtB,MAAAA,QAAQ,CAACyB,GAAT,CAAaM,KAAb,CAAmB,iDAAnB;AACA;AACH;;AACD,QAAI,CAACC,YAAD,EAAelB,OAAf,IAA0BD,aAAa,CAAC,KAAKO,YAAN,EAAoB,KAAKC,YAAzB,CAA3C;;AACA,QAAI,CAACW,YAAL,EAAmB;AACf;AACH;;AACD,QAAI,CAAC,KAAKX,YAAL,CAAkBlB,cAAvB,EAAuC;AACnCW,MAAAA,OAAO,CAACe,MAAR,CAAe,gBAAf;AACH;;AACD7B,IAAAA,QAAQ,CAACyB,GAAT,CAAaM,KAAb,CAAmB,yBAAnB,EAA8CjB,OAA9C,EAAuD,KAAKM,YAA5D;;AACA,QAAI;AACA,WAAKE,gBAAL,GAAwB,IAAxB;AACA,UAAIW,cAAc,GAAG,KAAKb,YAAL,CAAkBd,KAAlB,EAArB;;AACA,UAAI2B,cAAc,CAAC7B,YAAf,CAA4Ba,IAA5B,GAAmC,CAAvC,EAA0C;AACtC,YAAIiB,cAAc,GAAG,MAAM,KAAKC,kBAAL,CAAwBF,cAAxB,EAAwCnB,OAAxC,CAA3B;AACA,aAAKO,YAAL,CAAkBnB,KAAlB,GAA0BgC,cAAc,CAAChC,KAAzC;AACA,aAAKmB,YAAL,CAAkBlB,cAAlB,GAAmC+B,cAAc,CAAC/B,cAAlD;AACA,aAAKkB,YAAL,CAAkBjB,YAAlB,GAAiC8B,cAAc,CAAC9B,YAAhD;AACA,aAAKgC,IAAL,CAAU,cAAV,EAA0B,YAA1B;AACH,OAND,MAOK;AACD,cAAM,KAAKC,kBAAL,EAAN;AACA,aAAKhB,YAAL,CAAkBnB,KAAlB,GAA0B+B,cAAc,CAAC/B,KAAzC;AACA,aAAKmB,YAAL,CAAkBlB,cAAlB,GAAmC8B,cAAc,CAAC9B,cAAlD;AACA,aAAKkB,YAAL,CAAkBjB,YAAlB,CAA+BkC,KAA/B;AACA,aAAKF,IAAL,CAAU,cAAV,EAA0B,cAA1B;AACH;AACJ,KAjBD,SAkBQ;AACJ,WAAKd,gBAAL,GAAwB,KAAxB;AACAiB,MAAAA,UAAU,CAAC,MAAM,KAAKZ,mBAAL,EAAP,EAAmC,CAAnC,CAAV;AACH;AACJ;;AACDa,EAAAA,iBAAiB,CAACrC,cAAD,EAAiB;AAC9B,SAAKiB,YAAL,CAAkBjB,cAAlB,GAAmCA,cAAnC;AACA,SAAKwB,mBAAL;AACH;;AAtEyC;;AAwE9CjC,OAAO,CAACE,SAAR,GAAoBA,SAApB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Connector = exports.RegistrationState = void 0;\nconst events_1 = require(\"events\");\nconst logger_1 = require(\"./logger\");\nclass RegistrationState {\n    constructor(token = '', notificationId = '', messageTypes = new Set()) {\n        this.token = token;\n        this.notificationId = notificationId;\n        this.messageTypes = messageTypes;\n    }\n    clone() {\n        return new RegistrationState(this.token, this.notificationId, new Set(this.messageTypes));\n    }\n}\nexports.RegistrationState = RegistrationState;\nfunction setDifference(a, b) {\n    return [...[...a].filter(x => !b.has(x)),\n        ...[...b].filter(x => !a.has(x))];\n}\nfunction hasDifference(a, b) {\n    let reasons = new Set();\n    if (a.notificationId !== b.notificationId) {\n        reasons.add('notificationId');\n    }\n    if (a.token !== b.token) {\n        reasons.add('token');\n    }\n    if (setDifference(a.messageTypes, b.messageTypes).length > 0) {\n        reasons.add('messageType');\n    }\n    return [reasons.size > 0, reasons];\n}\nclass Connector extends events_1.EventEmitter {\n    constructor(config) {\n        super();\n        this.config = config;\n        this.desiredState = new RegistrationState();\n        this.currentState = new RegistrationState();\n        this.hasActiveAttempt = false;\n    }\n    async subscribe(messageType) {\n        if (this.desiredState.messageTypes.has(messageType)) {\n            logger_1.log.debug('message type already registered ', messageType);\n            return;\n        }\n        this.desiredState.messageTypes.add(messageType);\n        await this.persistRegistration();\n    }\n    async unsubscribe(messageType) {\n        if (!this.desiredState.messageTypes.has(messageType)) {\n            return;\n        }\n        this.desiredState.messageTypes.delete(messageType);\n        await this.persistRegistration();\n    }\n    updateToken(token) {\n        this.desiredState.token = token;\n        this.persistRegistration();\n    }\n    async persistRegistration() {\n        if (!this.config.token || this.config.token.length === 0) {\n            logger_1.log.trace('Can\\'t persist registration: token is not set');\n            return;\n        }\n        if (this.hasActiveAttempt) {\n            logger_1.log.trace('One registration attempt is already in progress');\n            return;\n        }\n        let [needToUpdate, reasons] = hasDifference(this.desiredState, this.currentState);\n        if (!needToUpdate) {\n            return;\n        }\n        if (!this.currentState.notificationId) {\n            reasons.delete('notificationId');\n        }\n        logger_1.log.trace('Persisting registration', reasons, this.desiredState);\n        try {\n            this.hasActiveAttempt = true;\n            let stateToPersist = this.desiredState.clone();\n            if (stateToPersist.messageTypes.size > 0) {\n                let persistedState = await this.updateRegistration(stateToPersist, reasons);\n                this.currentState.token = persistedState.token;\n                this.currentState.notificationId = persistedState.notificationId;\n                this.currentState.messageTypes = persistedState.messageTypes;\n                this.emit('stateChanged', 'registered');\n            }\n            else {\n                await this.removeRegistration();\n                this.currentState.token = stateToPersist.token;\n                this.currentState.notificationId = stateToPersist.notificationId;\n                this.currentState.messageTypes.clear();\n                this.emit('stateChanged', 'unregistered');\n            }\n        }\n        finally {\n            this.hasActiveAttempt = false;\n            setTimeout(() => this.persistRegistration(), 0);\n        }\n    }\n    setNotificationId(notificationId) {\n        this.desiredState.notificationId = notificationId;\n        this.persistRegistration();\n    }\n}\nexports.Connector = Connector;\n"]},"metadata":{},"sourceType":"script"}